## 双指针

### ==移动0==

#### 题目内容

##### 题目描述

给定整数数组 `nums`，将所有 `0` 移动到数组末尾，同时**保持非零元素的相对顺序不变**。要求**原地修改**（不能复制额外数组）。

##### 输入描述

输入两行：

* 第 1 行：整数 `n`，表示数组长度
* 第 2 行：`n` 个整数，空格分隔，表示数组 `nums`

##### 输出描述

输出移动后的数组，元素之间用空格分隔。

#### 原题解

```python
n = int(input().strip())
nums = list(map(int,input().strip().split()))
# nums.sort() 这里肯定不能排序，会改变数组的顺序
left = 0
for i in range(n):
    if nums[i] == 0:
        
        for j in range(i+1,n):
            if j != 0:
                nums[i],nums[j] = nums[j],nums[i]
                break

print(" ".join(list(map(str,nums))))
```

#### 原题解评价

* **评分**：3/10
* **时间复杂度**：O(n^2)（遇到 0 就向后再找非 0，重复扫描）
* **空间复杂度**：O(1)
* **优点**：

  * 有“原地交换”的方向意识
* **不足**：

  * **bug**：`if j != 0` 写错了，应为 `if nums[j] != 0`
  * 即使修正，也会大量重复查找，最坏 O(n^2) 易超时
  * 操作次数偏多（不满足进阶“尽量减少操作次数”的倾向）

#### 优化题解

```python
# 双指针：i 指向“下一个应该放非零的位置”，j 从左到右扫描
# 看到非零就放到 i 的位置，然后 i += 1
# 可选优化：当 i == j 时不交换（减少无意义的“自己换自己”）

n = int(input().strip())
nums = list(map(int, input().split()))

i = 0
for j in range(n):
    if nums[j] != 0:
        if i != j:  # 可选：减少操作次数；不影响正确性
            nums[i], nums[j] = nums[j], nums[i]
        i += 1

print(" ".join(map(str, nums)))
```

#### 总结与收获

* **小白视角的核心思路（用比喻记住）**
  把数组看成一排座位：

  * `j` 是“巡逻员”，从左到右检查
  * `i` 是“前排下一个空座位”（专门留给非零）
    巡逻员遇到非零，就把它安排到 `i` 的座位上，然后 `i` 往后挪一格。
    所有非零会按出现顺序依次坐到前排，剩下的位置自然就是 0。

* **关键不变式（你卡住时就靠它）**
  任何时刻都满足：`[0, i)` 全是非零，且顺序正确。
  所以 **i 只能在“成功放入一个非零”之后才 +1**。

* **为什么加 `if i != j`？（你问的点）**
  官方写法在 `i == j` 时也会执行交换，但那是“自己和自己换”，结果不变、只是多一次操作。
  加 `if i != j` 只是**减少无意义交换次数**，不影响正确性。

* **过程演示（官方版：遇到非零就交换）**
  例子：`[0, 1, 0, 3, 12]`
  初始：`nums=[0,1,0,3,12]，i=0`

  * `j=0`：nums[0]=0 → 跳过 → `i=0`
  * `j=1`：nums[1]=1 → 交换 nums[0],nums[1] → `[1,0,0,3,12]`，`i=1`
  * `j=2`：nums[2]=0 → 跳过 → `i=1`
  * `j=3`：nums[3]=3 → 交换 nums[1],nums[3] → `[1,3,0,0,12]`，`i=2`
  * `j=4`：nums[4]=12 → 交换 nums[2],nums[4] → `[1,3,12,0,0]`，`i=3`
    最终：`[1,3,12,0,0]`

* **解答你的疑问：为什么快慢指针想了很久没做出来？**
  你方向其实是对的（快 `j` + 慢 `i/left`），通常卡住是因为：

  1. **慢指针乱动**：遇到 0 也动，导致前面被 0 占着，整理不起来；正确是“只在放入非零后 i 才 +1”。
  2. **判断写成了下标**：像你原来 `j != 0` 这种，应该判断值 `nums[j] != 0`。

* **复杂度结论**

  * 时间复杂度：O(n)
  * 空间复杂度：O(1)

* **易错点清单**

  * 把 `nums[j] != 0` 写成 `j != 0`（下标 vs 值）
  * `i` 的含义不清：它是“下一个非零位置”，不是“下一个 0 的位置”
  * 以为要“把 0 往后推”，其实更稳的是“把非 0 往前收集”


### 省最多水的容器

#### 题目内容

##### 题目描述

给定长度为 `n` 的非负整数数组 `height`（第 `i` 条竖线坐标为 `(i,0)` 到 `(i,height[i])`），任选两条竖线与 `x` 轴构成容器。容器可盛水量为：
[
\text{area}(l,r)=\min(height[l],height[r])\cdot (r-l)
]
返回最大可盛水量。**容器不能倾斜**。

##### 输入描述

* 第 1 行：整数 `n`
* 第 2 行：`n` 个整数，表示 `height[0..n-1]`

##### 输出描述

* 输出一个整数：最大可盛水量

#### 原题解

```python
n = int(input().strip())
nums = list(map(int,input().strip().split()))
max_volume = 0
left,right = 0,n-1  
# 保证宽度有意义,这里不能取等号
while left < right:
    if nums[left]<=nums[right]:
        left += 1 # 贪心寻找更大的
        current_volume = (right-left)*min(nums[right],nums[left])
        max_volume = max(current_volume,max_volume)
    else:
        right -= 1
        current_volume = (right-left)*min(nums[right],nums[left])
        max_volume = max(current_volume,max_volume)
print(max_volume)
```

#### 原题解评价

* **评分**：5/10
* **时间复杂度**：`O(n)`（双指针单趟扫描）
* **空间复杂度**：`O(1)`
* **优点**：

  * 思路方向正确：尝试用双指针 + “短板决定高度”的贪心。
  * 复杂度达到了最优的量级。
* **不足**：

  1. **关键逻辑顺序错误（先移动指针再计算面积）**：会漏算当前 `(left,right)` 这一对的面积，导致在 `n=2` 等情况下直接错。例如 `height=[6,9]`，唯一答案应为 `6*(1)=6`，但你先 `left+=1`，宽度变 0，结果输出 0。
  2. “贪心寻找更大的” 的表述不够严谨：正确的贪心不是“找更大”，而是**证明可以安全丢弃短板**（下面总结给出严格证明）。
  3. `<=` 是否取等号与你的代码正确性无关（真正的问题是计算位置），但确实需要用严格证明澄清（见“总结与收获”）。

#### 优化题解

```python
# 双指针 + 贪心：每次丢弃短板（可证明不会错过最优解）
n = int(input().strip())
height = list(map(int, input().strip().split()))

left, right = 0, n - 1
ans = 0

while left < right:
    # 1) 先用当前(left,right)计算面积：不能漏掉这对
    h = min(height[left], height[right])
    ans = max(ans, h * (right - left))

    # 2) 再移动短板：只可能通过提高短板高度来弥补宽度变小
    if height[left] < height[right]:
        left += 1
    else:
        right -= 1

print(ans)
```

#### 总结与收获

* **专家视角的解题思路（本质：可证明的贪心删候选）**

  * 面积由两部分决定：宽度 `(r-l)` 与短板高度 `min(height[l],height[r])`。
  * 双指针从两端向内收缩：宽度必然变小，因此要想得到更大面积，**唯一希望是短板高度变大**。
  * 贪心决策不是“随便移动”，而是：**每一步都删除一批不可能成为最优解的候选对**。

* **严格数学证明：为什么移动短板是正确的贪心**

  * 设当前指针为 `(l,r)`，且 `height[l] <= height[r]`。
  * 对任何 `k` 满足 `l < k < r`，考虑所有以 `l` 为左边界的容器 `(l,k)`：
    [
    \text{area}(l,k)=\min(height[l],height[k])\cdot (k-l)\le height[l]\cdot (k-l)
    ]
    又因为 `k-l < r-l`，所以：
    [
    height[l]\cdot (k-l) < height[l]\cdot (r-l)=\min(height[l],height[r])\cdot (r-l)=\text{area}(l,r)
    ]
  * 结论：当 `height[l] <= height[r]` 时，**任何包含左边界 `l` 的更内侧组合 `(l,k)` 都不可能超过当前 `(l,r)`**。因此左边界 `l` 不可能出现在最优解中，可以安全丢弃，令 `l++`。
  * 对称地，当 `height[r] < height[l]` 时，安全丢弃 `r--`。
  * 这就是题解中“贪心”的严谨含义：**每步做出一个“可证明安全”的删除决策**，将搜索空间从 `O(n^2)` 降到 `O(n)`。

* **你的疑问解答**

  1. **为什么把面积计算放在 while 下面（循环开头）与放在 if/else 里面差别巨大？结合样例走一遍**

     * `while left < right` 的语义：每轮循环处理“当前状态的 (left,right)”，然后更新状态进入下一轮。
     * 正确结构必须是：**先计算当前 (left,right) 的面积 → 更新答案 → 再移动指针**。你原来是先移动再算，会漏掉当前这一对。
     * 用样例 `n=9, height=[1,8,6,2,5,4,8,3,7]`（展示关键几步）：

       * `(l=0,r=8)`：面积 `min(1,7)*8=8`，短板在左→`l=1`
       * `(1,8)`：面积 `min(8,7)*7=49`（最优已出现），短板在右→`r=7`
       * `(1,7)`：面积 `min(8,3)*6=18`，短板右→`r=6`
       * `(1,6)`：面积 `min(8,8)*5=40`，相等随便动一边→`r=5`（或 `l=2` 都行）
       * 后续宽度继续缩小，即便短板变高也很难超过 49，最终答案 49。
     * 反例说明你那种“先移动再算”为何会错：`height=[6,9]`

       * 正确：只有 `(0,1)`，面积 `6*1=6`
       * 你的做法：先 `l=1`，再算宽度 0，得到 0 ⇒ 漏算了唯一候选。
  2. **`nums[left] <= nums[right]` 是否应该取等号？给出严格结论**

     * 在正确算法里，分支写成 `<` 或 `<=` **都正确**，因为当两端相等 `height[l]==height[r]` 时：

       * 按上面的证明，`height[l] <= height[r]` 成立 ⇒ **丢弃 `l` 安全**；
       * 同时对称地 `height[r] <= height[l]` 也成立 ⇒ **丢弃 `r` 也安全**。
     * 因此：

       * `if height[l] < height[r]: l+=1 else: r-=1`（官方常见写法）✅
       * `if height[l] <= height[r]: l+=1 else: r-=1` ✅
         两者只影响路径，不影响正确性与复杂度。
  3. **是否还有其他解法？**

     * **暴力枚举**：枚举所有 `(i,j)`，`O(n^2)`，`n=1e5` 必超时。
     * **按高度降序加入下标（可作为“非最优但有趣”的等价思路）**：将下标按 `height` 从大到小排序，逐个加入集合并维护已加入下标的最小/最大值 `minIdx/maxIdx`，在处理到高度 `h` 时更新候选 `h*(maxIdx-minIdx)`。复杂度 `O(n log n)`（排序），正确但慢于双指针。
     * 结论：在通用比较模型下，**双指针 `O(n)` + `O(1)` 空间是最优、最简、最稳定** 的工程解。